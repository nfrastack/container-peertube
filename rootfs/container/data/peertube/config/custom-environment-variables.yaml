# SPDX-FileCopyrightText: Â© 2025 Nfrastack <code@nfrastack.com>
#
# SPDX-License-Identifier: MIT
# 7.3.0

listen:
  hostname: "LISTEN_HOSTNAME"
  port: "LISTEN_PORT"

webserver:
  hostname: "WEBSERVER_HOSTNAME"
  port:
    __name: "WEBSERVER_PORT"
    __format: "json"
  https:
    __name: "WEBSERVER_HTTPS"
    __format: "json"

secrets:
  peertube: "PEERTUBE_SECRET"

rates_limit:
  api:
    window: RATELIMIT_API_WINDOW
    max: RATELIMIT_API_MAX
  login:
    window: RATELIMIT_LOGIN_WINDOW
    max: RATELIMIT_LOGIN_MAX
  signup:
    window: RATELIMIT_SIGNUP_WINDOW
    max: RATELIMIT_SIGNUP_MAX
  ask_send_email:
    window: RATELIMIT_ASK_SEND_EMAIL_WINDOW
    max: RATELIMIT_ASK_SEND_EMAIL_MAX
  receive_client_log:
    window: RATELIMIT_RECEIVE_CLIENT_LOG_WINDOW
    max: RATELIMIT_RECEIVE_CLIENT_LOG_MAX
  plugins:
    window: RATELIMIT_PLUGINS_WINDOW
    max: RATELIMIT_PLUGINS_MAX
  well_known:
    window: RATELIMIT_WELLKNOWN_WINDOW
    max: RATELIMIT_WELLKNOWN_MAX
  feeds:
    window: RATELIMIT_FEEDS_WINDOW
    max: RATELIMIT_FEEDS_MAX
  activity_pub:
    window: RATELIMIT_ACTIVITYPUB_WINDOW
    max: RATELIMIT_ACTIVITYPUB_MAX
  client:
    window: RATELIMIT_CLIENT_WINDOW
    max: RATELIMIT_CLIENT_MAX
  download_generate_video:
    window: RATELIMIT_DOWNLOAD_GENERATE_VIDEO_WINDOW
    max: RATELIMIT_DOWNLOAD_GENERATE_VIDEO_MAX

###
oauth2:
  token_lifetime:
    access_token: '1 day'
    refresh_token: '2 weeks'

trust_proxy:
  __name: "TRUST_PROXY"
  __format: "json"

database:
  hostname: "DB_HOST"
  port: "DB_PORT"
  name: "DB_NAME"
  suffix: "DB_SUFFIX"
  username: "DB_USER"
  password: "DB_PASS"
  ssl:
    __name: "DB_SSL"
    __format: "json"
  ###
  #pool:
  #  max: 5

redis:
  hostname: "REDIS_HOST"
  port: "REDIS_PORT"
  auth: "REDIS_AUTH"
  ##db: 0

smtp:
  hostname: "SMTP_HOST"
  port: "SMTP_PORT"
  username: "SMTP_USER"
  password: "SMTP_PASS"
  tls:
    __name: "SMTP_TLS"
    __format: "json"
  disable_starttls:
    __name: "SMTP_DISABLE_STARTTLS"
    __format: "json"
  from_address: "SMTP_FROM"
  #ca_file: null # Used for self signed certificates

storage:
  tmp: "STORAGE_TMP_PATH"
  tmp_persistent: "STORAGE_TMP_PERSISTENT_PATH"
  bin: "STORAGE_BIN_PATH"
  avatars: "STORAGE_AVATAR_PATH"
  web_videos: "STORAGE_WEB_VIDEOS_PATH"
  streaming_playlists: "STORAGE_STREAMING_PLAYLISTS_PATH"
  original_video_files: "STORAGE_ORIGINAL_VIDEO_PATH"
  redundancy: "STORAGE_REDUNDANCY_PATH"
  logs: "LOG_PATH"
  previews: "STORAGE_PREVIEWS_PATH"
  thumbnails: "STORAGE_THUMBNAILS_PATH"
  storyboards: "STORAGE_STORYBOARDS_PATH"
  torrents: "STORAGE_TORRENTS_PATH"
  captions: "STORAGE_CAPTIONS_PATH"
  cache: "STORAGE_CACHE_PATH"
  plugins: "STORAGE_PLUGINS_PATH"
  well_known: "STORAGE_WELLKNOWN_PATH"
  uploads: "STORAGE_UPLOADS_PATH"
  client_overrides: "STORAGE_CLIENT_OVERRIDES_PATH"

static_files:
  private_files_require_auth:
    __name: "REQUIRE_AUTH_PRIVATE_FILES"
    __format: "json"

object_storage:
  enabled:
    __name: "ENABLE_OBJECT_STORAGE"
    __format: "json"

  endpoint: "OBJECT_STORAGE_ENDPOINT"

  region: "OBJECT_STORAGE_REGION"

  upload_acl:
    public: "OBJECT_STORAGE_UPLOADACL_PUBLIC"
    private: "OBJECT_STORAGE_UPLOADACL_PRIVATE"

  proxy:
    proxify_private_files: OBJECT_STORAGE_PROXY_PRIVATE_FILES

  credentials:
    access_key_id: "OBJECT_STORAGE_CREDENTIALS_ACCESS_KEY_ID"
    secret_access_key: "OBJECT_STORAGE_CREDENTIALS_SECRET_ACCESS_KEY"

  max_upload_part: OBJECT_STORAGE_MAX_UPLOAD_PART

  max_request_attempts: "OBJECT_STORAGE_MAX_REQUEST_ATTEMPTS"

  streaming_playlists:
    bucket_name: "OBJECT_STORAGE_STREAMING_PLAYLISTS_BUCKET_NAME"
    prefix: "OBJECT_STORAGE_STREAMING_PLAYLISTS_PREFIX"
    base_url: "OBJECT_STORAGE_STREAMING_PLAYLISTS_BASE_URL"
    store_live_streams: OBJECT_STORAGE_STREAMING_PLAYLISTS_STORE_LIVE_STREAMS
  web_videos:
    bucket_name: "OBJECT_STORAGE_WEB_VIDEOS_BUCKET_NAME"
    prefix: "OBJECT_STORAGE_WEB_VIDEOS_PREFIX"
    base_url: "OBJECT_STORAGE_WEB_VIDEOS_BASE_URL"
  user_exports:
    bucket_name: "OBJECT_STORAGE_USER_EXPORTS_BUCKET_NAME"
    prefix: "OBJECT_STORAGE_USER_EXPORTS_PREFIX"
    base_url: "OBJECT_STORAGE_USER_EXPORTS_BASE_URL"
  original_video_files:
    bucket_name: "OBJECT_STORAGE_ORIGINAL_VIDEO_BUCKET_NAME"
    prefix: "OBJECT_STORAGE_ORIGINAL_VIDEO_PREFIX"
    base_url: "OBJECT_STORAGE_ORIGINAL_VIDEO_BASE_URL"
  captions:
    bucket_name: "OBJECT_STORAGE_CAPTIONS_BUCKET_NAME"
    prefix: "OBJECT_STORAGE_CAPTIONS_PREFIX"
    base_url: "OBJECT_STORAGE_CAPTIONS_BASE_URL"

log:
  level: "LOG_LEVEL"
  rotation:
    enabled:
      __name: "FALSE"
      __format: "json"
  anonymize_ip:
    __name: "LOG_ANONYMIZE_IP"
    __format: "json"
  log_ping_requests:
    __name: "LOG_PING_REQUESTS"
    __format: "json"
  log_tracker_unknown_infohash:
    __name: "LOG_TRACKER_UNKNOWN_INFOHASH"
    __format: "json"
  log_http_requests:
    __name: "LOG_HTTP_REQUESTS"
    __format: "json"
  prettify_sql:
    __name: "LOG_PRETTIFY_SQL"
    __format: "json"
  accept_client_log:
    __name: "LOG_ACCEPT_CLIENT_LOGS"
    __format: "json"

open_telemetry:
  metrics:
    enabled:
      __name: "OPENTELEMETRY_METRICS_ENABLED"
      __format: "json"

    playback_stats_interval: "OPENTELEMETRY_METRICS_PLAYBACK_STATS_INTERVAL"

    http_request_duration:
      enabled:
        __name: "OPENTELEMETRY_METRICS_HTTP_REQUEST_DURATION_ENABLED"
        __format: "json"

    prometheus_exporter:
      hostname: "OPENTELEMETRY_METRICS_PROMETHEUS_EXPORTER_HOST"
      port: "OPENTELEMETRY_METRICS_PROMETHEUS_EXPORTER_PORT"

  tracing:
    enabled:
      __name: "OPENTELEMETRY_TRACING_ENABLED"
      __format: "json"

    jaeger_exporter:
      endpoint: "OPENTELEMETRY_TRACING_JAEGER_EXPORTER_ENDPOINT"

#trending:
#  videos:
#    interval_days: 7 # Compute trending videos for the last x days for 'most-viewed' algorithm
#    algorithms:
#      enabled:
#        - 'hot' # Adaptation of Reddit's 'Hot' algorithm
#        - 'most-viewed' # Number of views in the last x days
#        - 'most-liked' # Global views since the upload of the video
#      default: 'hot'
## Cache remote videos on your server, to help other instances to broadcast the video
## You can define multiple caches using different sizes/strategies
## Once you have defined your strategies, choose which instances you want to cache in admin -> manage follows -> following
#redundancy:
#  videos:
#    check_interval: '1 hour' # How often you want to check new videos to cache
#    strategies: # Just uncomment strategies you want
##      -
##        size: '10GB'
##        # Minimum time the video must remain in the cache. Only accept values > 10 hours (to not overload remote instances)
##        min_lifetime: '48 hours'
##        strategy: 'most-views' # Cache videos that have the most views
##      -
##        size: '10GB'
##        # Minimum time the video must remain in the cache. Only accept values > 10 hours (to not overload remote instances)
##        min_lifetime: '48 hours'
##        strategy: 'trending' # Cache trending videos
##      -
##        size: '10GB'
##        # Minimum time the video must remain in the cache. Only accept values > 10 hours (to not overload remote instances)
##        min_lifetime: '48 hours'
##        strategy: 'recently-added' # Cache recently added videos
##        min_views: 10 # Having at least x views
#
## Other instances that duplicate your content
#remote_redundancy:
#  videos:
#    # PeerTube doesn't remove existing redundancies when you change this setting
#    # You can remove them in the web interface: https://docs.joinpeertube.org/admin/following-instances#instances-redundancy
#    # Available values:
#    #  * nobody: Do not accept remote redundancies
#    #  * followings: Accept redundancies from instance followings
#    #  * anybody: Accept remote redundancies from anybody
#    accept_from: 'anybody'
#
csp:
  enabled:
    __name: "ENABLE_CSP"
    __format: "json"

  report_only:
    __name: "CSP_REPORT_ONLY"
    __format: "json"

security:
  frameguard:
    enabled:
      __name: "SECURITY_ENABLE_FRAMEGUARD"
      __format: "json"
  powered_by_header:
    enabled:
      __name: "SECURITY_ENABLE_POWERED_BY_HEADER"
      __format: "json"

tracker:
  enabled:
    __name: "ENABLE_TRACKER"
    __format: "json"
  private:
    __name: "TRACKER_PRIVATE"
    __format: "json"
  reject_too_many_announces:
    __name: "TRACKER_REJECT_TOO_MANY_ANNOUNCES"
    __format: "json"

#history:
#  videos:
#    # If you want to limit users videos history
#    # -1 means there is no limitations
#    # Other values could be '6 months' or '30 days' etc (PeerTube will periodically delete old entries from database)
#    max_age: -1

#views:
#  videos:
#    # PeerTube creates a database entry every hour for each video to track views over a period of time
#    # This is used in particular by the Trending page
#    # PeerTube could remove old remote video views if you want to reduce your database size (video view counter will not be altered)
#    # -1 means no cleanup
#    # Other values could be '6 months' or '30 days' etc (PeerTube will periodically delete old entries from database)
#    remote:
#      max_age: '30 days'
#    # PeerTube buffers local video views before updating and federating the video
#    local_buffer_update_interval: '30 minutes'
#    # How long does it take to count again a view from the same user
#    view_expiration: '1 hour'
#    # Minimum amount of time the viewer has to watch the video before PeerTube adds a view
#    count_view_after: '10 seconds'
#    # Player can send a session id string to track the user
#    # Since this can be spoofed by users to create fake views, you have the option to disable this feature
#    # If disabled, PeerTube will use the IP address to track the same user (default behavior before PeerTube 6.1)
#    trust_viewer_session_id: true
#    # How often the web browser sends "is watching" information to the server
#    # Increase the value or set null to disable it if you plan to have many viewers
#    watching_interval:
#      # Non logged-in viewers
#      anonymous: '5 seconds'
#      # Logged-in users of your instance
#      # Unlike anonymous viewers, this endpoint is also used to store the "last watched video timecode" for your users
#      # Increasing this value reduces the accuracy of the video resume
#      users: '5 seconds'
## Used to get country location of views of local videos
#geo_ip:
#  enabled: true
#  country:
#    database_url: 'https://dbip.mirror.framasoft.org/files/dbip-country-lite-latest.mmdb'
#  city:
#    database_url: 'https://dbip.mirror.framasoft.org/files/dbip-city-lite-latest.mmdb'
#plugins:
#  # The website PeerTube will ask for available PeerTube plugins and themes
#  # This is an unmoderated plugin index, so only install plugins/themes you trust
#  index:
#    enabled: true
#    check_latest_versions_interval: '4 hours' # How often you want to check new plugins/themes versions
#    url: 'https://packages.joinpeertube.org'

federation:
  enabled:
    __name: "ENABLE_FEDERATION"
    __format: "json"

  prevent_ssrf:
    __name: "FEDERATION_PREVENT_SSRF"
    __format: "json"

  sign_federated_fetches:
    __name: "FEDERATION_SIGN_FETCHES"
    __format: "json"

  videos:
    federate_unlisted:
      __name: "FEDERATION_VIDEOS_UNLISTED"
      __format: "json"

    cleanup_remote_interactions:
      __name: "FEDERATION_VIDEOS_CLEANUP_REMOTE_INTERACTIONS"
      __format: "json"

peertube:
  check_latest_version:
    enabled:
      __name: "ENABLE_CHECK_LATEST_VERSION"
      __format: "json"
    url: "CHECK_LATEST_VERSION_URL"

webadmin:
  configuration:
    edition:
      allowed:
        __name: "STATS_ENABLE_REGISTRATION_REQUESTS"
        __format: "json"

## XML, Atom or JSON feeds
#feeds:
#  videos:
#    # Default number of videos displayed in feeds
#    count: 20
#  comments:
#    # Default number of comments displayed in feeds
#    count: 20
#remote_runners:
#  # Consider jobs that are processed by a remote runner as stalled after this period of time without any update
#  stalled_jobs:
#    live: '30 seconds'
#    vod: '2 minutes'
#    studio: '2 minutes'
#    transcription: '2 minutes'
#thumbnails:
#  # When automatically generating a thumbnail from the video
#  generation_from_video:
#    # How many frames to analyze at the middle of the video to select the most appropriate one
#    # Increasing this value will increase CPU and memory usage when generating the thumbnail, especially for high video resolution
#    # Minimum value is 2
#    frames_to_analyze: 50
#  # Only two sizes are currently supported for now (not less, not more)
#  # 1 size for the thumbnail (displayed in video miniatures)
#  # 1 size for the preview (displayed in the video player)
#  sizes:
#    - width: 280
#      height: 157
#    - width: 850
#      height: 480

stats:
  registration_requests:
    enabled:
      __name: "STATS_ENABLE_REGISTRATION_REQUESTS"
      __format: "json"

  abuses:
    enabled:
      __name: "STATS_ENABLE_REGISTRATION_ABUSES"
      __format: "json"

  total_moderators:
    enabled:
      __name: "STATS_ENABLE_TOTAL_MODERATORS"
      __format: "json"

  total_admins:
    enabled:
      __name: "STATS_ENABLE_TOTAL_ADMINS"
      __format: "json"

#webrtc:
#  # 1 or 2 STUN servers are sufficient
#  stun_servers:
#    - 'stun:stunserver2024.stunprotocol.org'
#    - 'stun:stun.framasoft.org'
#nsfw_flags_settings:
#  # Allow logged-in/anonymous users to have a more granular control over their NSFW policy
#  # using NSFW flags (violent content, etc.) set by video authors
#  enabled: true
#
#download_generate_video:
#  # Max parallel downloads on your instance
#  # Each download spawns an ffmpeg process
#  # The ffmpeg process ends when users have downloaded the entire file or cancelled the download
#  max_parallel_downloads: 100
#

admin:
  email: "PEERTUBE_ADMIN_EMAIL"

contact_form:
  enabled: "PEERTUBE_CONTACT_FORM_ENABLED"

signup:
  enabled: "PEERTUBE_SIGNUP_ENABLED"
  limit: "PEERTUBE_SIGNUP_LIMIT"

user:
  video_quota: "PEERTUBE_USER_VIDEO_QUOTA"

transcoding:
  enabled: "PEERTUBE_TRANSCODING_ENABLED"
  threads: "PEERTUBE_TRANSCODING_THREADS"
  resolutions:
    144p: "PEERTUBE_TRANSCODING_144P"
    240p: "PEERTUBE_TRANSCODING_240P"
    360p: "PEERTUBE_TRANSCODING_360P"
    480p: "PEERTUBE_TRANSCODING_480P"
    720p: "PEERTUBE_TRANSCODING_720P"
    1080p: "PEERTUBE_TRANSCODING_1080P"
    1440p: "PEERTUBE_TRANSCODING_1440P"
    2160p: "PEERTUBE_TRANSCODING_2160P"
  web_videos:
    enabled: "PEERTUBE_TRANSCODING_WEB_VIDEOS_ENABLED"
  hls:
    enabled: "PEERTUBE_TRANSCODING_HLS_ENABLED"

instance:
  name: "PEERTUBE_INSTANCE_NAME"
  description: "PEERTUBE_INSTANCE_DESCRIPTION"
  terms: "PEERTUBE_INSTANCE_TERMS"

search:
  remote_uri:
    users: "PEERTUBE_SEARCH_REMOTEURI_USERS"
    anonymous: "PEERTUBE_SEARCH_REMOTEURI_ANONYMOUS"

defaults:
  publish:
    download_enabled:
        __name: "DEFAULT_PUBLISH_ENABLE_DOWNLOAD"
        __format: "json"
    comments_policy: "DEFAULT_PUBLISH_COMMENTS_POLICY"
    privacy: "DEFAULT_PUBLIC_PRIVACY"
    license: "DEFAULT_PUBLIC_LICENSE"

  p2p:
    webapp:
      enabled:
        __name: "DEFAULT_P2P_ENABLE_WEBAPP"
        __format: "json"
    embed:
      enabled:
        __name: "DEFAULT_P2P_ENABLE_EMBED"
        __format: "json"

email:
  body:
    signature: "EMAIL_BODY_SIGNATURE"
  subject:
    prefix: "EMAIL_SUBJECT_PREFIX"












import:
  videos:
    http:
      enabled: "PEERTUBE_IMPORT_VIDEOS_HTTP"
    torrent:
      enabled: "PEERTUBE_IMPORT_VIDEOS_TORRENT"
